#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>

typedef struct {
int process_id;
int page_number;
int last_accessed;
} memory;

// Declared arrays and 
memory* RAM[16] = {NULL}; 
int simulation_time_step = 0;    
int page_counter[4]  = {-1, -1, -1, -1};
//pages for process      0,  1,  2,  3

int page_table[4][4] = { {99, 99, 99, 99}, {99, 99, 99, 99}, {99, 99, 99, 99}, {99, 99, 99, 99} };
//tables for process id:  0                 1                 2                 3 

void initialize_ram() {
    for (int RAM_index  = 0; RAM_index < 16; RAM_index++) {
         RAM[RAM_index] = NULL; 
    } 
}     

//find smallest step time for local process 
void find_local_page_LRU(int *LRU, int *smallest_step_time, int current_process_id) {
    for (int RAM_index = 0; RAM_index < 16; RAM_index += 2) {
        if (RAM[RAM_index]->process_id == current_process_id && RAM[RAM_index]->last_accessed < *smallest_step_time) {
			*smallest_step_time = RAM[RAM_index]->last_accessed;
			*LRU = RAM_index; 
        }
    }
}

void find_global_page_LRU(int *LRU, int *smallest_step_time, int current_process_id) {
	for (int RAM_index = 0; RAM_index < 16; RAM_index += 2) {
		if (RAM[RAM_index]->last_accessed < *smallest_step_time) {
			*smallest_step_time = RAM[RAM_index]->last_accessed;
			*LRU = RAM_index; 
		}
	}
}

void process_request(int process_id[], int total_processes) {
	
    for (int index = 0; index < total_processes; index++) {	
    
        int current_process_id = process_id[index];    
		page_counter[current_process_id] = (page_counter[current_process_id] + 1) % 4;
		int requested_page = page_counter[current_process_id];
        simulation_time_step++;  

		if (page_table[current_process_id][requested_page] == 99) {
		    
			int RAM_space_available = 0;
			// Find an empty slot in RAM to load the page
			for (int RAM_index = 0; RAM_index < 16; RAM_index += 2) {
				if (RAM[RAM_index] == NULL) { 
					RAM[RAM_index] = (memory*)malloc(sizeof(memory));
					RAM[RAM_index] -> process_id    = current_process_id   ;
					RAM[RAM_index] -> page_number   = requested_page       ;
					RAM[RAM_index] -> last_accessed = simulation_time_step ;

					RAM[RAM_index + 1] = RAM[RAM_index]; 
					page_table[current_process_id][requested_page] = RAM_index / 2;
					
                    RAM_space_available = 1;
					break;  
				}	
			}
			
			if (RAM_space_available == 0) {
				
				int LRU = -1; 
				int smallest_step_time = simulation_time_step + 1;
				
				find_local_page_LRU(&LRU, &smallest_step_time, current_process_id);
					
				if (LRU == -1) {
					find_global_page_LRU(&LRU, &smallest_step_time, current_process_id);
					
	
				}
				// Evict the LRU page
				int evicted_process_id = RAM[LRU]->process_id;
				int evicted_page_number = RAM[LRU]->page_number;
				page_table[evicted_process_id][evicted_page_number] = 99;  // Mark evicted page as on disk

				// Load the new page in the LRU slot
				RAM[LRU]->process_id = current_process_id;
				RAM[LRU]->page_number = requested_page;
				RAM[LRU]->last_accessed = simulation_time_step;
				RAM[LRU + 1] = RAM[LRU];  // Load into two contiguous slots

				// Update page table for the current process
				page_table[current_process_id][requested_page] = LRU / 2;
				
			}
	
		} else {
			// If the page is already in RAM, update its last accessed time
			int frame_number = page_table[current_process_id][requested_page] * 2;  // Get frame's starting index in RAM
			RAM[frame_number]->last_accessed = simulation_time_step;  // Update the last access time
		}
	
	}
}

char process_id_array(FILE *file, int process_ids[], int *total_processes) {
    int index = 0;
	char character;
    while ((character  = fgetc(file))     != EOF) {
        if (character >= '0' && character <= '3') {
            process_ids[index++]           = character - '0';
			(*total_processes)++; 
        }
    }
	
	printf("Digits read from file:\n");
    for (int i = 0;   i < index;  i++) {
        printf("%d ", process_ids[i]);
    }
	
    printf("\n");
    return 0;
}

void print_ram_contents() {
    // Print RAM contents
    printf("RAM Contents: ");

    for (int i = 0; i < 16; i++) {
        if (RAM[i] != NULL) {
            // Print process_id, page_number, and last_accessed for each RAM slot
            printf("%d,%d,%d", RAM[i]->process_id, RAM[i]->page_number, RAM[i]->last_accessed);
        } else {
            // For empty slots, use placeholders like "Empty"
            printf("Empty");
        }

        // Add a semicolon after each entry except the last one
        if (i < 15) {
            printf("; ");
        }
    }
    printf(" (16 entries)\n");

    // Print the page tables for all processes
    printf("\nPage Tables:\n");
    for (int process_id = 0; process_id < 4; process_id++) {
        printf("Process %d Page Table: ", process_id);
        
        for (int page_number = 0; page_number < 4; page_number++) {
            if (page_table[process_id][page_number] != 99) {
                // Page is in RAM, print the frame number
                printf("%d ", page_table[process_id][page_number]);
            } else {
                // Page is on disk, print 99
                printf("99 ");
            }
        }
        printf("\n");  // Newline after each process's page table
    }
}

void print_ram_contents_output_file(const char *file) {
	FILE *output = fopen(file, "w");
	
	fprintf(output, "RAM: [");
	for (int i = 0; i < 16; i++) {
        if (RAM[i] != NULL) {
			fprintf(output, "%d,%d,%d", RAM[i]->process_id, RAM[i]->page_number, RAM[i]->last_accessed);
        } else {
			fprintf(output, "---");
        }
        
        if (i < 15) {fprintf(output, "; ");
        }
    }
	fprintf(output, "]");
	
	// Print the page tables for all processes
    fprintf(output,"\nPage Tables:\n");
    for (int process_id = 0; process_id < 4; process_id++) {
        fprintf(output, "Process %d Page Table: ", process_id);
        
        for (int page_number = 0; page_number < 4; page_number++) {
            if (page_table[process_id][page_number] != 99) {
                // Page is in RAM, print the frame number
                fprintf(output,"0%d ", page_table[process_id][page_number]);
            } else {
                // Page is on disk, print 99
                fprintf(output,"99 ");
            }
        }
        fprintf(output,"\n");  // Newline after each process's page table
    }
	fclose(output);
}


int main(int arguement_count, char *arguement_value[]) {
    FILE *file = fopen(arguement_value[1], "r");
	int total_processes = 0;                                
	int process_ids[100];                                    //Array to store string for process
                                                            
	initialize_ram();                                        //Initialize NULL RAM of 16 
	process_id_array(file, process_ids, &total_processes);   //Read file/copy contents to array. Counts number of processes 
	process_request(process_ids, total_processes);           //Simulates virtual memory
	print_ram_contents();
	print_ram_contents_output_file(arguement_value[2]);      //Writes RAM content to file

    fclose(file);
}
